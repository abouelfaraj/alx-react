import { ParserServices, TSESTree } from '../ts-estree';
import { ParserOptions as TSParserOptions } from './ParserOptions';
import { RuleCreateFunction, RuleFix, RuleModule, SharedConfigurationSettings } from './Rule';
import { Scope } from './Scope';
import { SourceCode } from './SourceCode';
declare class LinterBase {
    /**
     * Initialize the Linter.
     * @param config the config object
     */
    constructor(config?: Linter.LinterOptions);
    /**
     * Define a new parser module
     * @param parserId Name of the parser
     * @param parserModule The parser object
     */
    defineParser(parserId: string, parserModule: Linter.ParserModule): void;
    /**
     * Defines a new linting rule.
     * @param ruleId A unique rule identifier
     * @param ruleModule Function from context to object mapping AST node types to event handlers
     */
    defineRule<TMessageIds extends string, TOptions extends readonly unknown[]>(ruleId: string, ruleModule: RuleModule<TMessageIds, TOptions> | RuleCreateFunction): void;
    /**
     * Defines many new linting rules.
     * @param rulesToDefine map from unique rule identifier to rule
     */
    defineRules<TMessageIds extends string, TOptions extends readonly unknown[]>(rulesToDefine: Record<string, RuleModule<TMessageIds, TOptions> | RuleCreateFunction>): void;
    /**
     * Gets an object with all loaded rules.
     * @returns All loaded rules
     */
    getRules(): Map<string, RuleModule<string, unknown[]>>;
    /**
     * Gets the `SourceCode` object representing the parsed source.
     * @returns The `SourceCode` object.
     */
    getSourceCode(): SourceCode;
    /**
     * Verifies the text against the rules specified by the second argument.
     * @param textOrSourceCode The text to parse or a SourceCode object.
     * @param config An ESLintConfig instance to configure everything.
     * @param filenameOrOptions The optional filename of the file being checked.
     *        If this is not set, the filename will default to '<input>' in the rule context.
     *        If this is an object, then it has "filename", "allowInlineConfig", and some properties.
     * @returns The results as an array of messages or an empty array if no messages.
     */
    verify(textOrSourceCode: SourceCode | string, config: Linter.Config, filenameOrOptions?: string | Linter.VerifyOptions): Linter.LintMessage[];
    /**
     * Performs multiple autofix passes over the text until as many fixes as possible have been applied.
     * @param code The source text to apply fixes to.
     * @param config The ESLint config object to use.
     * @param options The ESLint options object to use.
     * @returns The result of the fix operation as returned from the SourceCodeFixer.
     */
    verifyAndFix(code: string, config: Linter.Config, options: Linter.FixOptions): Linter.FixReport;
    /**
     * The version from package.json.
     */
    readonly version: string;
    /**
     * The version from package.json.
     */
    static readonly version: string;
}
declare namespace Linter {
    export interface LinterOptions {
        /**
         * path to a directory that should be considered as the current working directory.
         */
        cwd?: string;
    }
    export type Severity = 0 | 1 | 2;
    export type SeverityString = 'off' | 'warn' | 'error';
    export type RuleLevel = Severity | SeverityString;
    export type RuleLevelAndOptions = [
        RuleLevel,
        ...unknown[]
    ];
    export type RuleEntry = RuleLevel | RuleLevelAndOptions;
    export type RulesRecord = Partial<Record<string, RuleEntry>>;
    export type GlobalVariableOption = 'readonly' | 'writable' | 'off' | boolean;
    interface BaseConfig {
        $schema?: string;
        /**
         * The environment settings.
         */
        env?: {
            [name: string]: boolean;
        };
        /**
         * The path to other config files or the package name of shareable configs.
         */
        extends?: st